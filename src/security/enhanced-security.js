// ðŸ” Enhanced Security Configuration\n// Advanced security measures for Smart Factory\n\nclass EnhancedSecurityManager {\n    constructor() {\n        this.securityConfig = {\n            encryption: {\n                algorithm: 'AES-256-GCM',\n                keyRotation: '30d',\n                saltRounds: 12\n            },\n            authentication: {\n                mfa_required: true,\n                session_timeout: '8h',\n                max_failed_attempts: 3,\n                lockout_duration: '15min'\n            },\n            authorization: {\n                rbac_enabled: true,\n                principle_of_least_privilege: true,\n                audit_all_access: true\n            }\n        };\n        \n        this.securityHeaders = {\n            'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',\n            'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'\",\n            'X-Frame-Options': 'DENY',\n            'X-Content-Type-Options': 'nosniff',\n            'Referrer-Policy': 'strict-origin-when-cross-origin',\n            'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'\n        };\n        \n        this.initialize();\n    }\n    \n    // ðŸ” Initialize security measures\n    async initialize() {\n        console.log('ðŸ” Initializing enhanced security measures...');\n        \n        // Setup input validation\n        this.setupInputValidation();\n        \n        // Initialize rate limiting\n        this.setupRateLimiting();\n        \n        // Setup audit logging\n        this.setupAuditLogging();\n        \n        // Initialize threat detection\n        this.setupThreatDetection();\n        \n        console.log('âœ… Enhanced security initialized');\n    }\n    \n    // ðŸ›¡ï¸ Input validation and sanitization\n    setupInputValidation() {\n        this.inputValidator = {\n            sanitizeInput: (input) => {\n                if (typeof input !== 'string') return input;\n                \n                return input\n                    .replace(/<script[^>]*>.*?<\\/script>/gi, '')\n                    .replace(/<[^>]+>/g, '')\n                    .replace(/javascript:/gi, '')\n                    .replace(/on\\w+=\"[^\"]*\"/gi, '')\n                    .replace(/'/g, '&#x27;')\n                    .replace(/\"/g, '&quot;')\n                    .trim();\n            },\n            \n            validateApiInput: (data, schema) => {\n                const errors = [];\n                \n                for (const field in schema) {\n                    const value = data[field];\n                    const rules = schema[field];\n                    \n                    // Required field validation\n                    if (rules.required && (value === undefined || value === null)) {\n                        errors.push(`${field} is required`);\n                        continue;\n                    }\n                    \n                    // Type validation\n                    if (value !== undefined && rules.type && typeof value !== rules.type) {\n                        errors.push(`${field} must be of type ${rules.type}`);\n                    }\n                    \n                    // Length validation\n                    if (value && rules.maxLength && value.length > rules.maxLength) {\n                        errors.push(`${field} exceeds maximum length of ${rules.maxLength}`);\n                    }\n                    \n                    // Pattern validation\n                    if (value && rules.pattern && !rules.pattern.test(value)) {\n                        errors.push(`${field} format is invalid`);\n                    }\n                }\n                \n                return {\n                    isValid: errors.length === 0,\n                    errors: errors\n                };\n            }\n        };\n    }\n    \n    // ðŸš¦ Rate limiting implementation\n    setupRateLimiting() {\n        this.rateLimiter = new Map();\n        \n        this.checkRateLimit = (clientId, endpoint) => {\n            const key = `${clientId}:${endpoint}`;\n            const now = Date.now();\n            const windowMs = 60000; // 1 minute window\n            \n            const limits = {\n                '/api/chat': { max: 30, window: windowMs },\n                '/api/predictions': { max: 100, window: windowMs },\n                '/api/commands': { max: 10, window: windowMs },\n                'default': { max: 200, window: windowMs }\n            };\n            \n            const limit = limits[endpoint] || limits.default;\n            \n            if (!this.rateLimiter.has(key)) {\n                this.rateLimiter.set(key, {\n                    count: 1,\n                    resetTime: now + limit.window\n                });\n                return { allowed: true, remaining: limit.max - 1 };\n            }\n            \n            const record = this.rateLimiter.get(key);\n            \n            if (now > record.resetTime) {\n                record.count = 1;\n                record.resetTime = now + limit.window;\n                return { allowed: true, remaining: limit.max - 1 };\n            }\n            \n            if (record.count >= limit.max) {\n                return {\n                    allowed: false,\n                    remaining: 0,\n                    resetTime: record.resetTime\n                };\n            }\n            \n            record.count++;\n            return {\n                allowed: true,\n                remaining: limit.max - record.count\n            };\n        };\n    }\n    \n    // ðŸ“‹ Security audit logging\n    setupAuditLogging() {\n        this.auditLogger = {\n            logSecurityEvent: (event) => {\n                const auditRecord = {\n                    timestamp: new Date().toISOString(),\n                    eventType: event.type,\n                    severity: event.severity || 'INFO',\n                    userId: event.userId,\n                    sessionId: event.sessionId,\n                    ipAddress: event.ipAddress,\n                    userAgent: event.userAgent,\n                    resource: event.resource,\n                    action: event.action,\n                    outcome: event.outcome,\n                    details: event.details,\n                    riskScore: this.calculateRiskScore(event)\n                };\n                \n                // Log to secure audit trail\n                this.writeToAuditTrail(auditRecord);\n                \n                // Alert on high-risk events\n                if (auditRecord.riskScore > 7) {\n                    this.triggerSecurityAlert(auditRecord);\n                }\n            },\n            \n            logDataAccess: (userId, resource, action) => {\n                this.logSecurityEvent({\n                    type: 'DATA_ACCESS',\n                    userId: userId,\n                    resource: resource,\n                    action: action,\n                    severity: resource.includes('sensitive') ? 'HIGH' : 'MEDIUM'\n                });\n            },\n            \n            logAuthenticationEvent: (userId, outcome, details) => {\n                this.logSecurityEvent({\n                    type: 'AUTHENTICATION',\n                    userId: userId,\n                    action: 'LOGIN_ATTEMPT',\n                    outcome: outcome,\n                    severity: outcome === 'FAILURE' ? 'MEDIUM' : 'LOW',\n                    details: details\n                });\n            }\n        };\n    }\n    \n    // ðŸ” Threat detection system\n    setupThreatDetection() {\n        this.threatDetector = {\n            suspiciousActivities: new Map(),\n            \n            detectAnomalousPatterns: (userId, action, context) => {\n                const key = `${userId}:${action}`;\n                const now = Date.now();\n                \n                if (!this.suspiciousActivities.has(key)) {\n                    this.suspiciousActivities.set(key, {\n                        count: 1,\n                        firstSeen: now,\n                        lastSeen: now,\n                        contexts: [context]\n                    });\n                    return { threat: false };\n                }\n                \n                const activity = this.suspiciousActivities.get(key);\n                activity.count++;\n                activity.lastSeen = now;\n                activity.contexts.push(context);\n                \n                // Detect rapid repeated actions\n                const timeWindow = 300000; // 5 minutes\n                if (activity.count > 20 && (now - activity.firstSeen) < timeWindow) {\n                    return {\n                        threat: true,\n                        type: 'RAPID_REPEATED_ACTIONS',\n                        severity: 'HIGH',\n                        details: `${activity.count} ${action} actions in ${(now - activity.firstSeen) / 1000} seconds`\n                    };\n                }\n                \n                // Detect unusual access patterns\n                const uniqueContexts = new Set(activity.contexts.map(c => c.ipAddress));\n                if (uniqueContexts.size > 5) {\n                    return {\n                        threat: true,\n                        type: 'MULTIPLE_IP_ACCESS',\n                        severity: 'MEDIUM',\n                        details: `Access from ${uniqueContexts.size} different IP addresses`\n                    };\n                }\n                \n                return { threat: false };\n            },\n            \n            analyzeRequestPattern: (request) => {\n                const suspiciousPatterns = [\n                    /'\\s*(OR|AND)\\s*'\\s*=\\s*'/i, // SQL injection\n                    /<script[^>]*>.*?<\\/script>/gi, // XSS\n                    /\\.\\.[\\/\\\\]/g, // Path traversal\n                    /exec\\s*\\(/i, // Command injection\n                    /eval\\s*\\(/i // Code injection\n                ];\n                \n                const requestString = JSON.stringify(request);\n                \n                for (const pattern of suspiciousPatterns) {\n                    if (pattern.test(requestString)) {\n                        return {\n                            threat: true,\n                            type: 'INJECTION_ATTEMPT',\n                            severity: 'CRITICAL',\n                            pattern: pattern.source\n                        };\n                    }\n                }\n                \n                return { threat: false };\n            }\n        };\n    }\n    \n    // ðŸ” Secure API middleware\n    createSecureApiMiddleware() {\n        return async (req, res, next) => {\n            try {\n                // Apply security headers\n                Object.entries(this.securityHeaders).forEach(([header, value]) => {\n                    res.setHeader(header, value);\n                });\n                \n                // Extract client information\n                const clientId = this.extractClientId(req);\n                const endpoint = req.path;\n                const ipAddress = req.ip || req.connection.remoteAddress;\n                \n                // Check rate limiting\n                const rateLimit = this.checkRateLimit(clientId, endpoint);\n                if (!rateLimit.allowed) {\n                    this.auditLogger.logSecurityEvent({\n                        type: 'RATE_LIMIT_EXCEEDED',\n                        severity: 'MEDIUM',\n                        userId: clientId,\n                        ipAddress: ipAddress,\n                        resource: endpoint\n                    });\n                    \n                    return res.status(429).json({\n                        error: 'Rate limit exceeded',\n                        resetTime: rateLimit.resetTime\n                    });\n                }\n                \n                // Validate input\n                if (req.body) {\n                    const threatAnalysis = this.threatDetector.analyzeRequestPattern(req.body);\n                    if (threatAnalysis.threat) {\n                        this.auditLogger.logSecurityEvent({\n                            type: 'THREAT_DETECTED',\n                            severity: threatAnalysis.severity,\n                            userId: clientId,\n                            ipAddress: ipAddress,\n                            details: threatAnalysis\n                        });\n                        \n                        return res.status(400).json({\n                            error: 'Invalid request detected'\n                        });\n                    }\n                }\n                \n                // Check for suspicious activity patterns\n                const activityAnalysis = this.threatDetector.detectAnomalousPatterns(\n                    clientId,\n                    req.method + ' ' + endpoint,\n                    { ipAddress, userAgent: req.get('User-Agent') }\n                );\n                \n                if (activityAnalysis.threat) {\n                    this.auditLogger.logSecurityEvent({\n                        type: 'SUSPICIOUS_ACTIVITY',\n                        severity: activityAnalysis.severity,\n                        userId: clientId,\n                        ipAddress: ipAddress,\n                        details: activityAnalysis\n                    });\n                    \n                    // Don't block immediately, but log for monitoring\n                    console.warn('ðŸš¨ Suspicious activity detected:', activityAnalysis);\n                }\n                \n                // Continue to next middleware\n                next();\n                \n            } catch (error) {\n                console.error('ðŸ” Security middleware error:', error);\n                res.status(500).json({ error: 'Security validation failed' });\n            }\n        };\n    }\n    \n    // ðŸ”‘ Extract client ID from request\n    extractClientId(req) {\n        return req.user?.id || \n               req.sessionID || \n               req.ip || \n               'anonymous';\n    }\n    \n    // âš ï¸ Calculate risk score for events\n    calculateRiskScore(event) {\n        let score = 0;\n        \n        // Base score by event type\n        const typeScores = {\n            'AUTHENTICATION': 2,\n            'DATA_ACCESS': 3,\n            'THREAT_DETECTED': 8,\n            'RATE_LIMIT_EXCEEDED': 4,\n            'SUSPICIOUS_ACTIVITY': 6\n        };\n        \n        score += typeScores[event.type] || 1;\n        \n        // Severity multiplier\n        const severityMultipliers = {\n            'LOW': 1,\n            'MEDIUM': 2,\n            'HIGH': 3,\n            'CRITICAL': 4\n        };\n        \n        score *= severityMultipliers[event.severity] || 1;\n        \n        // Failed outcome increases score\n        if (event.outcome === 'FAILURE') {\n            score += 2;\n        }\n        \n        return Math.min(score, 10);\n    }\n    \n    // ðŸ“ Write to audit trail\n    writeToAuditTrail(record) {\n        // In production, this would write to secure logging service\n        console.log('ðŸ” AUDIT:', JSON.stringify(record, null, 2));\n        \n        // Store in secure audit database\n        if (typeof localStorage !== 'undefined') {\n            const auditLogs = JSON.parse(localStorage.getItem('security_audit_logs') || '[]');\n            auditLogs.push(record);\n            \n            // Keep only last 1000 records\n            if (auditLogs.length > 1000) {\n                auditLogs.splice(0, auditLogs.length - 500);\n            }\n            \n            localStorage.setItem('security_audit_logs', JSON.stringify(auditLogs));\n        }\n    }\n    \n    // ðŸš¨ Trigger security alert\n    triggerSecurityAlert(record) {\n        console.error('ðŸš¨ SECURITY ALERT:', record);\n        \n        // In production, integrate with incident management system\n        const alertData = {\n            timestamp: new Date().toISOString(),\n            severity: 'HIGH',\n            title: `Security Event: ${record.eventType}`,\n            description: `High-risk security event detected: ${record.details}`,\n            user: record.userId,\n            ip: record.ipAddress,\n            riskScore: record.riskScore\n        };\n        \n        // Send to monitoring systems\n        this.sendToSecurityTeam(alertData);\n        \n        // Update dashboard with security status\n        if (typeof window !== 'undefined' && window.updateSecurityStatus) {\n            window.updateSecurityStatus(alertData);\n        }\n    }\n    \n    // ðŸ“§ Send alert to security team\n    sendToSecurityTeam(alert) {\n        // Simulate sending to security monitoring\n        console.log('ðŸ“§ Sending security alert to team:', alert.title);\n        \n        // In production, integrate with:\n        // - SIEM systems\n        // - Slack/Teams notifications\n        // - Email alerts\n        // - SMS for critical events\n    }\n    \n    // ðŸ“Š Get security metrics\n    getSecurityMetrics() {\n        const auditLogs = typeof localStorage !== 'undefined' \n            ? JSON.parse(localStorage.getItem('security_audit_logs') || '[]')\n            : [];\n            \n        const last24h = auditLogs.filter(log => \n            Date.now() - new Date(log.timestamp).getTime() < 86400000\n        );\n        \n        return {\n            total_events_24h: last24h.length,\n            high_risk_events: last24h.filter(log => log.riskScore >= 7).length,\n            authentication_failures: last24h.filter(log => \n                log.eventType === 'AUTHENTICATION' && log.outcome === 'FAILURE'\n            ).length,\n            threat_detections: last24h.filter(log => \n                log.eventType === 'THREAT_DETECTED'\n            ).length,\n            average_risk_score: last24h.length > 0 \n                ? last24h.reduce((sum, log) => sum + log.riskScore, 0) / last24h.length\n                : 0,\n            unique_users: new Set(last24h.map(log => log.userId)).size\n        };\n    }\n}\n\n// ðŸš€ Initialize enhanced security\nconst enhancedSecurity = new EnhancedSecurityManager();\n\n// Export for dashboard integration\nif (typeof window !== 'undefined') {\n    window.EnhancedSecurity = enhancedSecurity;\n    \n    // Add security status to dashboard\n    window.getSecurityStatus = () => enhancedSecurity.getSecurityMetrics();\n}\n\nexport default EnhancedSecurityManager;