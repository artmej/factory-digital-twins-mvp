// üåü Advanced Particle System for Digital Twin Data Visualization\n// Real-time data flow, health indicators, and environmental effects\n\nclass DigitalTwinParticleSystem {\n    constructor(scene, materials) {\n        this.scene = scene;\n        this.materials = materials;\n        this.particleSystems = new Map();\n        this.clock = new THREE.Clock();\n        \n        // Particle system configurations\n        this.configs = {\n            dataFlow: {\n                count: 500,\n                lifetime: 3.0,\n                speed: 2.0,\n                size: 0.1,\n                color: 0x00aaff\n            },\n            healthIndicator: {\n                count: 100,\n                lifetime: 2.0,\n                speed: 0.5,\n                size: 0.15,\n                color: 0x00ff88\n            },\n            alertSystem: {\n                count: 50,\n                lifetime: 1.5,\n                speed: 1.0,\n                size: 0.2,\n                color: 0xff4757\n            },\n            energyFlow: {\n                count: 200,\n                lifetime: 4.0,\n                speed: 1.5,\n                size: 0.08,\n                color: 0xffaa00\n            },\n            environmental: {\n                count: 1000,\n                lifetime: 10.0,\n                speed: 0.1,\n                size: 0.05,\n                color: 0x888888\n            }\n        };\n        \n        this.init();\n    }\n    \n    init() {\n        console.log('üåü Initializing Digital Twin Particle Systems...');\n        this.createParticleSystems();\n    }\n    \n    // üé¨ Create All Particle Systems\n    createParticleSystems() {\n        // Data Flow Particles (IoT data streams)\n        this.createDataFlowSystem();\n        \n        // Health Indicator Particles\n        this.createHealthIndicatorSystem();\n        \n        // Alert System Particles\n        this.createAlertSystem();\n        \n        // Energy Flow Visualization\n        this.createEnergyFlowSystem();\n        \n        // Environmental Effects\n        this.createEnvironmentalSystem();\n    }\n    \n    // üìä Data Flow Particle System\n    createDataFlowSystem() {\n        const config = this.configs.dataFlow;\n        \n        // Geometry for particles\n        const geometry = new THREE.BufferGeometry();\n        const positions = new Float32Array(config.count * 3);\n        const velocities = new Float32Array(config.count * 3);\n        const lifetimes = new Float32Array(config.count);\n        const sizes = new Float32Array(config.count);\n        const colors = new Float32Array(config.count * 3);\n        \n        // Initialize particle attributes\n        for (let i = 0; i < config.count; i++) {\n            const i3 = i * 3;\n            \n            // Random starting positions around data sources\n            positions[i3] = (Math.random() - 0.5) * 50;\n            positions[i3 + 1] = Math.random() * 5;\n            positions[i3 + 2] = (Math.random() - 0.5) * 30;\n            \n            // Random velocities\n            velocities[i3] = (Math.random() - 0.5) * config.speed;\n            velocities[i3 + 1] = Math.random() * config.speed * 0.5;\n            velocities[i3 + 2] = (Math.random() - 0.5) * config.speed;\n            \n            // Random lifetimes\n            lifetimes[i] = Math.random() * config.lifetime;\n            \n            // Random sizes\n            sizes[i] = config.size * (0.5 + Math.random() * 0.5);\n            \n            // Base color with slight variation\n            const color = new THREE.Color(config.color);\n            colors[i3] = color.r + (Math.random() - 0.5) * 0.2;\n            colors[i3 + 1] = color.g + (Math.random() - 0.5) * 0.2;\n            colors[i3 + 2] = color.b + (Math.random() - 0.5) * 0.2;\n        }\n        \n        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));\n        geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));\n        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));\n        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n        \n        // Shader material for data particles\n        const material = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0 },\n                dataIntensity: { value: 1.0 },\n                pointTexture: { value: this.createParticleTexture() }\n            },\n            vertexShader: this.getDataFlowVertexShader(),\n            fragmentShader: this.getDataFlowFragmentShader(),\n            transparent: true,\n            blending: THREE.AdditiveBlending\n        });\n        \n        const particles = new THREE.Points(geometry, material);\n        this.scene.add(particles);\n        \n        this.particleSystems.set('dataFlow', {\n            particles,\n            geometry,\n            material,\n            config,\n            velocities,\n            lifetimes,\n            maxLifetime: config.lifetime\n        });\n    }\n    \n    // üè• Health Indicator Particle System\n    createHealthIndicatorSystem() {\n        const config = this.configs.healthIndicator;\n        \n        const geometry = new THREE.BufferGeometry();\n        const positions = new Float32Array(config.count * 3);\n        const healthValues = new Float32Array(config.count);\n        const ages = new Float32Array(config.count);\n        \n        // Initialize health indicator particles around machines\n        for (let i = 0; i < config.count; i++) {\n            const i3 = i * 3;\n            \n            // Position around machines (simulate multiple machine locations)\n            const angle = (i / config.count) * Math.PI * 2;\n            const radius = 1 + Math.random() * 3;\n            positions[i3] = Math.cos(angle) * radius;\n            positions[i3 + 1] = 0.5 + Math.random() * 2;\n            positions[i3 + 2] = Math.sin(angle) * radius;\n            \n            // Random health values (0-1)\n            healthValues[i] = Math.random();\n            \n            // Random ages\n            ages[i] = Math.random() * config.lifetime;\n        }\n        \n        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        geometry.setAttribute('healthValue', new THREE.BufferAttribute(healthValues, 1));\n        geometry.setAttribute('age', new THREE.BufferAttribute(ages, 1));\n        \n        const material = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0 },\n                maxLifetime: { value: config.lifetime },\n                pointTexture: { value: this.createParticleTexture() }\n            },\n            vertexShader: this.getHealthIndicatorVertexShader(),\n            fragmentShader: this.getHealthIndicatorFragmentShader(),\n            transparent: true,\n            blending: THREE.AdditiveBlending\n        });\n        \n        const particles = new THREE.Points(geometry, material);\n        this.scene.add(particles);\n        \n        this.particleSystems.set('healthIndicator', {\n            particles,\n            geometry,\n            material,\n            config,\n            healthValues,\n            ages\n        });\n    }\n    \n    // üö® Alert System Particles\n    createAlertSystem() {\n        const config = this.configs.alertSystem;\n        \n        // Create expandable alert rings\n        const geometry = new THREE.RingGeometry(0.1, 2, 16);\n        const material = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0 },\n                alertLevel: { value: 0.0 }, // 0-1 alert intensity\n                color: { value: new THREE.Color(config.color) }\n            },\n            vertexShader: `\n                varying vec2 vUv;\n                uniform float time;\n                \n                void main() {\n                    vUv = uv;\n                    vec3 pos = position;\n                    \n                    // Pulsing effect\n                    float pulse = sin(time * 5.0) * 0.1 + 1.0;\n                    pos *= pulse;\n                    \n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n                }\n            `,\n            fragmentShader: `\n                uniform float time;\n                uniform float alertLevel;\n                uniform vec3 color;\n                varying vec2 vUv;\n                \n                void main() {\n                    vec2 center = vUv - vec2(0.5);\n                    float dist = length(center);\n                    \n                    // Create ring effect\n                    float ring = smoothstep(0.3, 0.35, dist) * smoothstep(0.5, 0.45, dist);\n                    \n                    // Pulsing intensity\n                    float pulse = sin(time * 8.0) * 0.5 + 0.5;\n                    float alpha = ring * alertLevel * pulse;\n                    \n                    gl_FragColor = vec4(color, alpha);\n                }\n            `,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            side: THREE.DoubleSide\n        });\n        \n        // Create multiple alert rings for different severity levels\n        const alertRings = [];\n        for (let i = 0; i < 5; i++) {\n            const ring = new THREE.Mesh(geometry.clone(), material.clone());\n            ring.visible = false; // Initially hidden\n            ring.rotation.x = -Math.PI / 2; // Lay flat\n            this.scene.add(ring);\n            alertRings.push(ring);\n        }\n        \n        this.particleSystems.set('alertSystem', {\n            rings: alertRings,\n            material,\n            config,\n            activeAlerts: []\n        });\n    }\n    \n    // ‚ö° Energy Flow Particle System\n    createEnergyFlowSystem() {\n        const config = this.configs.energyFlow;\n        \n        // Create flowing energy lines between machines\n        const curves = this.generateEnergyFlowCurves();\n        \n        curves.forEach((curve, index) => {\n            const geometry = new THREE.BufferGeometry();\n            const points = curve.getPoints(50);\n            const positions = new Float32Array(points.length * 3);\n            const progress = new Float32Array(points.length);\n            \n            points.forEach((point, i) => {\n                positions[i * 3] = point.x;\n                positions[i * 3 + 1] = point.y;\n                positions[i * 3 + 2] = point.z;\n                progress[i] = i / (points.length - 1);\n            });\n            \n            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n            geometry.setAttribute('progress', new THREE.BufferAttribute(progress, 1));\n            \n            const material = new THREE.ShaderMaterial({\n                uniforms: {\n                    time: { value: 0 },\n                    flowSpeed: { value: config.speed },\n                    energyLevel: { value: 0.8 },\n                    color: { value: new THREE.Color(config.color) }\n                },\n                vertexShader: `\n                    attribute float progress;\n                    varying float vProgress;\n                    uniform float time;\n                    uniform float flowSpeed;\n                    \n                    void main() {\n                        vProgress = progress;\n                        \n                        vec3 pos = position;\n                        // Add slight wave motion\n                        pos.y += sin(progress * 10.0 + time * flowSpeed) * 0.1;\n                        \n                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n                        gl_PointSize = 3.0;\n                    }\n                `,\n                fragmentShader: `\n                    uniform float time;\n                    uniform float flowSpeed;\n                    uniform float energyLevel;\n                    uniform vec3 color;\n                    varying float vProgress;\n                    \n                    void main() {\n                        // Moving energy pulse\n                        float pulse = fract(vProgress - time * flowSpeed * 0.1);\n                        float intensity = smoothstep(0.8, 0.0, pulse) * energyLevel;\n                        \n                        gl_FragColor = vec4(color * intensity, intensity);\n                    }\n                `,\n                transparent: true,\n                blending: THREE.AdditiveBlending\n            });\n            \n            const line = new THREE.Points(geometry, material);\n            this.scene.add(line);\n        });\n    }\n    \n    // üå´Ô∏è Environmental Effect System\n    createEnvironmentalSystem() {\n        const config = this.configs.environmental;\n        \n        // Create ambient particles for atmosphere\n        const geometry = new THREE.BufferGeometry();\n        const positions = new Float32Array(config.count * 3);\n        const velocities = new Float32Array(config.count * 3);\n        const opacities = new Float32Array(config.count);\n        \n        for (let i = 0; i < config.count; i++) {\n            const i3 = i * 3;\n            \n            // Random positions throughout the factory\n            positions[i3] = (Math.random() - 0.5) * 100;\n            positions[i3 + 1] = Math.random() * 15;\n            positions[i3 + 2] = (Math.random() - 0.5) * 60;\n            \n            // Very slow random movement\n            velocities[i3] = (Math.random() - 0.5) * config.speed;\n            velocities[i3 + 1] = Math.random() * config.speed * 0.5;\n            velocities[i3 + 2] = (Math.random() - 0.5) * config.speed;\n            \n            // Very low opacity\n            opacities[i] = Math.random() * 0.1;\n        }\n        \n        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));\n        geometry.setAttribute('opacity', new THREE.BufferAttribute(opacities, 1));\n        \n        const material = new THREE.PointsMaterial({\n            color: config.color,\n            size: config.size,\n            transparent: true,\n            opacity: 0.1,\n            blending: THREE.AdditiveBlending\n        });\n        \n        const particles = new THREE.Points(geometry, material);\n        this.scene.add(particles);\n        \n        this.particleSystems.set('environmental', {\n            particles,\n            geometry,\n            material,\n            config,\n            velocities\n        });\n    }\n    \n    // üé® Create Particle Texture\n    createParticleTexture() {\n        const canvas = document.createElement('canvas');\n        canvas.width = 64;\n        canvas.height = 64;\n        \n        const ctx = canvas.getContext('2d');\n        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);\n        gradient.addColorStop(0, 'rgba(255,255,255,1)');\n        gradient.addColorStop(0.5, 'rgba(255,255,255,0.5)');\n        gradient.addColorStop(1, 'rgba(255,255,255,0)');\n        \n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, 64, 64);\n        \n        return new THREE.CanvasTexture(canvas);\n    }\n    \n    // üåä Generate Energy Flow Curves\n    generateEnergyFlowCurves() {\n        const curves = [];\n        \n        // Define connection points between machines\n        const connectionPoints = [\n            { from: new THREE.Vector3(-15, 1, -15), to: new THREE.Vector3(0, 1, -10) },\n            { from: new THREE.Vector3(0, 1, -10), to: new THREE.Vector3(15, 1, -5) },\n            { from: new THREE.Vector3(15, 1, -5), to: new THREE.Vector3(-10, 1, 5) },\n            { from: new THREE.Vector3(-10, 1, 5), to: new THREE.Vector3(10, 1, 15) }\n        ];\n        \n        connectionPoints.forEach(connection => {\n            // Create curved path with control points\n            const midPoint = connection.from.clone().lerp(connection.to, 0.5);\n            midPoint.y += 2; // Arc upward\n            \n            const curve = new THREE.QuadraticBezierCurve3(\n                connection.from,\n                midPoint,\n                connection.to\n            );\n            \n            curves.push(curve);\n        });\n        \n        return curves;\n    }\n    \n    // üìä Shader Programs\n    getDataFlowVertexShader() {\n        return `\n            attribute vec3 velocity;\n            attribute float lifetime;\n            attribute float size;\n            attribute vec3 color;\n            \n            uniform float time;\n            \n            varying float vLifetime;\n            varying vec3 vColor;\n            \n            void main() {\n                vLifetime = lifetime;\n                vColor = color;\n                \n                // Update particle position based on velocity and time\n                vec3 pos = position + velocity * time;\n                \n                // Wrap particles that go out of bounds\n                pos.x = mod(pos.x + 25.0, 50.0) - 25.0;\n                pos.z = mod(pos.z + 15.0, 30.0) - 15.0;\n                \n                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n                gl_PointSize = size * 100.0 / length(mvPosition.xyz);\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        `;\n    }\n    \n    getDataFlowFragmentShader() {\n        return `\n            uniform sampler2D pointTexture;\n            uniform float dataIntensity;\n            \n            varying float vLifetime;\n            varying vec3 vColor;\n            \n            void main() {\n                vec4 texColor = texture2D(pointTexture, gl_PointCoord);\n                \n                // Fade based on lifetime\n                float alpha = sin(vLifetime * 3.14159) * dataIntensity;\n                \n                gl_FragColor = vec4(vColor * texColor.rgb, alpha * texColor.a);\n            }\n        `;\n    }\n    \n    getHealthIndicatorVertexShader() {\n        return `\n            attribute float healthValue;\n            attribute float age;\n            \n            uniform float time;\n            uniform float maxLifetime;\n            \n            varying float vHealthValue;\n            varying float vAge;\n            \n            void main() {\n                vHealthValue = healthValue;\n                vAge = age;\n                \n                vec3 pos = position;\n                \n                // Float upward based on health\n                pos.y += sin(time + age) * 0.5 * healthValue;\n                \n                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n                \n                // Size based on health value\n                gl_PointSize = 10.0 + healthValue * 20.0;\n                \n                gl_Position = projectionMatrix * mvPosition;\n            }\n        `;\n    }\n    \n    getHealthIndicatorFragmentShader() {\n        return `\n            uniform sampler2D pointTexture;\n            \n            varying float vHealthValue;\n            varying float vAge;\n            \n            void main() {\n                vec4 texColor = texture2D(pointTexture, gl_PointCoord);\n                \n                // Health-based color (red to green)\n                vec3 healthColor = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vHealthValue);\n                \n                // Pulsing effect\n                float pulse = sin(vAge * 5.0) * 0.3 + 0.7;\n                \n                gl_FragColor = vec4(healthColor * texColor.rgb * pulse, texColor.a * 0.8);\n            }\n        `;\n    }\n    \n    // üîÑ Update Systems\n    update(deltaTime) {\n        this.updateDataFlow(deltaTime);\n        this.updateHealthIndicators(deltaTime);\n        this.updateAlertSystem(deltaTime);\n        this.updateEnergyFlow(deltaTime);\n        this.updateEnvironmental(deltaTime);\n    }\n    \n    updateDataFlow(deltaTime) {\n        const system = this.particleSystems.get('dataFlow');\n        if (!system) return;\n        \n        system.material.uniforms.time.value += deltaTime;\n        \n        // Update particle lifetimes\n        const lifetimes = system.lifetimes;\n        for (let i = 0; i < lifetimes.length; i++) {\n            lifetimes[i] -= deltaTime;\n            if (lifetimes[i] <= 0) {\n                lifetimes[i] = system.maxLifetime;\n            }\n        }\n        \n        system.geometry.attributes.lifetime.needsUpdate = true;\n    }\n    \n    updateHealthIndicators(deltaTime) {\n        const system = this.particleSystems.get('healthIndicator');\n        if (!system) return;\n        \n        system.material.uniforms.time.value += deltaTime;\n        \n        // Update ages\n        const ages = system.ages;\n        for (let i = 0; i < ages.length; i++) {\n            ages[i] += deltaTime;\n        }\n        \n        system.geometry.attributes.age.needsUpdate = true;\n    }\n    \n    updateAlertSystem(deltaTime) {\n        const system = this.particleSystems.get('alertSystem');\n        if (!system) return;\n        \n        system.material.uniforms.time.value += deltaTime;\n    }\n    \n    updateEnergyFlow(deltaTime) {\n        // Update energy flow materials\n        this.scene.traverse((object) => {\n            if (object.material && object.material.uniforms && object.material.uniforms.time) {\n                object.material.uniforms.time.value += deltaTime;\n            }\n        });\n    }\n    \n    updateEnvironmental(deltaTime) {\n        const system = this.particleSystems.get('environmental');\n        if (!system) return;\n        \n        const positions = system.geometry.attributes.position.array;\n        const velocities = system.velocities;\n        \n        // Update particle positions\n        for (let i = 0; i < positions.length; i += 3) {\n            positions[i] += velocities[i] * deltaTime;\n            positions[i + 1] += velocities[i + 1] * deltaTime;\n            positions[i + 2] += velocities[i + 2] * deltaTime;\n            \n            // Wrap particles\n            if (Math.abs(positions[i]) > 50) velocities[i] *= -1;\n            if (positions[i + 1] > 15 || positions[i + 1] < 0) velocities[i + 1] *= -1;\n            if (Math.abs(positions[i + 2]) > 30) velocities[i + 2] *= -1;\n        }\n        \n        system.geometry.attributes.position.needsUpdate = true;\n    }\n    \n    // üö® Trigger Alert\n    triggerAlert(position, severity = 'warning') {\n        const system = this.particleSystems.get('alertSystem');\n        if (!system) return;\n        \n        // Find available alert ring\n        const availableRing = system.rings.find(ring => !ring.visible);\n        if (availableRing) {\n            availableRing.position.copy(position);\n            availableRing.visible = true;\n            availableRing.material.uniforms.alertLevel.value = severity === 'critical' ? 1.0 : 0.6;\n            \n            // Auto-hide after duration\n            setTimeout(() => {\n                availableRing.visible = false;\n            }, 5000);\n        }\n    }\n    \n    // üìä Update Data Intensity\n    setDataIntensity(intensity) {\n        const system = this.particleSystems.get('dataFlow');\n        if (system && system.material.uniforms.dataIntensity) {\n            system.material.uniforms.dataIntensity.value = intensity;\n        }\n    }\n    \n    // üè• Update Health Values\n    updateHealthValues(machineId, healthScore) {\n        // Update health indicator particles for specific machine\n        const system = this.particleSystems.get('healthIndicator');\n        if (system) {\n            // Update health values based on machine ID\n            // Implementation depends on machine-particle mapping\n        }\n    }\n    \n    // üßπ Cleanup\n    dispose() {\n        this.particleSystems.forEach(system => {\n            if (system.geometry) system.geometry.dispose();\n            if (system.material) system.material.dispose();\n            if (system.particles) this.scene.remove(system.particles);\n            if (system.rings) {\n                system.rings.forEach(ring => {\n                    this.scene.remove(ring);\n                    ring.geometry.dispose();\n                    ring.material.dispose();\n                });\n            }\n        });\n        \n        this.particleSystems.clear();\n        console.log('üßπ Particle systems cleaned up');\n    }\n}\n\n// üöÄ Export for use in other modules\nif (typeof window !== 'undefined') {\n    window.DigitalTwinParticleSystem = DigitalTwinParticleSystem;\n}\n\nexport default DigitalTwinParticleSystem;