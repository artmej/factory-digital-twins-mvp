// üé® Advanced 3D Materials & Shaders for Digital Twins\n// Ultra-realistic materials and effects for Smart Factory visualization\n\nclass Advanced3DMaterials {\n    constructor() {\n        this.textureLoader = new THREE.TextureLoader();\n        this.cubeTextureLoader = new THREE.CubeTextureLoader();\n        \n        // Material cache for performance\n        this.materialCache = new Map();\n        \n        // Shader uniforms for dynamic effects\n        this.shaderUniforms = {\n            time: { value: 0.0 },\n            machineStatus: { value: 0.0 }, // 0 = off, 1 = running, 2 = warning, 3 = error\n            healthScore: { value: 1.0 }, // 0-1 health score\n            temperature: { value: 20.0 },\n            vibration: { value: 0.0 }\n        };\n        \n        this.init();\n    }\n    \n    init() {\n        console.log('üé® Initializing Advanced 3D Materials...');\n        this.createProceduralTextures();\n        this.createAdvancedShaders();\n        this.setupEnvironmentMaps();\n    }\n    \n    // üè≠ Industrial Floor Material with Wear Patterns\n    createIndustrialFloorMaterial() {\n        const cacheKey = 'industrial_floor';\n        if (this.materialCache.has(cacheKey)) {\n            return this.materialCache.get(cacheKey).clone();\n        }\n        \n        // Create concrete texture with normal and roughness maps\n        const diffuseTexture = this.createConcreteTexture();\n        const normalTexture = this.createConcreteNormalMap();\n        const roughnessTexture = this.createConcreteRoughnessMap();\n        \n        const material = new THREE.MeshStandardMaterial({\n            map: diffuseTexture,\n            normalMap: normalTexture,\n            roughnessMap: roughnessTexture,\n            metalness: 0.1,\n            roughness: 0.8,\n            envMapIntensity: 0.3\n        });\n        \n        this.materialCache.set(cacheKey, material);\n        return material.clone();\n    }\n    \n    // ü§ñ Smart Machine Material with Status Indication\n    createSmartMachineMaterial(machineId, status = 'running') {\n        const material = new THREE.ShaderMaterial({\n            uniforms: {\n                ...this.shaderUniforms,\n                baseColor: { value: new THREE.Color(0x2c3e50) },\n                statusColor: { value: this.getStatusColor(status) },\n                metalness: { value: 0.8 },\n                roughness: { value: 0.2 },\n                envMap: { value: this.getEnvironmentMap() }\n            },\n            vertexShader: this.getAdvancedVertexShader(),\n            fragmentShader: this.getMachineFragmentShader()\n        });\n        \n        return material;\n    }\n    \n    // ‚ú® Holographic Digital Twin Material\n    createHolographicMaterial(opacity = 0.7) {\n        const material = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0.0 },\n                opacity: { value: opacity },\n                color1: { value: new THREE.Color(0x00ffff) },\n                color2: { value: new THREE.Color(0x0066ff) },\n                scanlineFrequency: { value: 20.0 },\n                glitchIntensity: { value: 0.1 }\n            },\n            vertexShader: `\n                varying vec3 vPosition;\n                varying vec3 vNormal;\n                varying vec2 vUv;\n                \n                void main() {\n                    vPosition = position;\n                    vNormal = normal;\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `,\n            fragmentShader: `\n                uniform float time;\n                uniform float opacity;\n                uniform vec3 color1;\n                uniform vec3 color2;\n                uniform float scanlineFrequency;\n                uniform float glitchIntensity;\n                \n                varying vec3 vPosition;\n                varying vec3 vNormal;\n                varying vec2 vUv;\n                \n                void main() {\n                    // Scanlines effect\n                    float scanlines = sin(vUv.y * scanlineFrequency + time * 2.0) * 0.1 + 0.9;\n                    \n                    // Holographic interference\n                    float interference = sin(vPosition.y * 5.0 + time) * sin(vPosition.x * 3.0 + time * 0.7) * 0.1;\n                    \n                    // Color gradient based on height and normal\n                    float colorMix = (vPosition.y + 1.0) * 0.5 + dot(vNormal, vec3(0.0, 1.0, 0.0)) * 0.2;\n                    vec3 finalColor = mix(color1, color2, colorMix + interference);\n                    \n                    // Glitch effect\n                    if (sin(time * 10.0) > 0.95) {\n                        finalColor *= 1.0 + glitchIntensity;\n                    }\n                    \n                    gl_FragColor = vec4(finalColor * scanlines, opacity);\n                }\n            `,\n            transparent: true,\n            side: THREE.DoubleSide,\n            blending: THREE.AdditiveBlending\n        });\n        \n        return material;\n    }\n    \n    // üî• Heat Visualization Material\n    createHeatVisualizationMaterial(temperature = 20) {\n        const material = new THREE.ShaderMaterial({\n            uniforms: {\n                temperature: { value: temperature },\n                minTemp: { value: 15.0 },\n                maxTemp: { value: 80.0 },\n                time: { value: 0.0 }\n            },\n            vertexShader: `\n                varying vec2 vUv;\n                varying vec3 vPosition;\n                \n                void main() {\n                    vUv = uv;\n                    vPosition = position;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `,\n            fragmentShader: `\n                uniform float temperature;\n                uniform float minTemp;\n                uniform float maxTemp;\n                uniform float time;\n                \n                varying vec2 vUv;\n                varying vec3 vPosition;\n                \n                vec3 temperatureToColor(float temp) {\n                    float normalizedTemp = clamp((temp - minTemp) / (maxTemp - minTemp), 0.0, 1.0);\n                    \n                    // Heat map colors: blue -> green -> yellow -> red\n                    if (normalizedTemp < 0.25) {\n                        return mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), normalizedTemp * 4.0);\n                    } else if (normalizedTemp < 0.5) {\n                        return mix(vec3(0.0, 1.0, 1.0), vec3(0.0, 1.0, 0.0), (normalizedTemp - 0.25) * 4.0);\n                    } else if (normalizedTemp < 0.75) {\n                        return mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (normalizedTemp - 0.5) * 4.0);\n                    } else {\n                        return mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (normalizedTemp - 0.75) * 4.0);\n                    }\n                }\n                \n                void main() {\n                    // Add thermal noise\n                    float noise = sin(vPosition.x * 10.0 + time) * sin(vPosition.y * 15.0 + time * 0.7) * 0.05;\n                    float adjustedTemp = temperature + noise * 5.0;\n                    \n                    vec3 heatColor = temperatureToColor(adjustedTemp);\n                    \n                    // Add pulsing effect for extreme temperatures\n                    if (adjustedTemp > maxTemp * 0.8) {\n                        float pulse = sin(time * 8.0) * 0.3 + 0.7;\n                        heatColor *= pulse;\n                    }\n                    \n                    gl_FragColor = vec4(heatColor, 0.8);\n                }\n            `,\n            transparent: true\n        });\n        \n        return material;\n    }\n    \n    // ‚ö° Energy Flow Visualization Material\n    createEnergyFlowMaterial() {\n        const material = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0.0 },\n                flowSpeed: { value: 2.0 },\n                energyLevel: { value: 0.8 },\n                color1: { value: new THREE.Color(0x00ff88) },\n                color2: { value: new THREE.Color(0x88ff00) }\n            },\n            vertexShader: `\n                varying vec2 vUv;\n                varying vec3 vPosition;\n                \n                void main() {\n                    vUv = uv;\n                    vPosition = position;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `,\n            fragmentShader: `\n                uniform float time;\n                uniform float flowSpeed;\n                uniform float energyLevel;\n                uniform vec3 color1;\n                uniform vec3 color2;\n                \n                varying vec2 vUv;\n                varying vec3 vPosition;\n                \n                void main() {\n                    // Moving energy waves\n                    float wave1 = sin(vUv.x * 10.0 - time * flowSpeed) * 0.5 + 0.5;\n                    float wave2 = sin(vUv.x * 15.0 - time * flowSpeed * 1.3) * 0.3 + 0.7;\n                    \n                    // Energy pulses\n                    float pulse = sin(time * 3.0) * 0.2 + 0.8;\n                    \n                    // Combine waves\n                    float intensity = wave1 * wave2 * energyLevel * pulse;\n                    \n                    vec3 finalColor = mix(color1, color2, intensity) * intensity;\n                    \n                    gl_FragColor = vec4(finalColor, intensity * 0.9);\n                }\n            `,\n            transparent: true,\n            blending: THREE.AdditiveBlending\n        });\n        \n        return material;\n    }\n    \n    // üìä Data Visualization Particle Material\n    createDataParticleMaterial() {\n        const material = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0.0 },\n                dataIntensity: { value: 1.0 },\n                particleSize: { value: 10.0 },\n                color: { value: new THREE.Color(0x00aaff) }\n            },\n            vertexShader: `\n                uniform float time;\n                uniform float particleSize;\n                \n                attribute float life;\n                attribute float speed;\n                \n                varying float vLife;\n                varying float vSpeed;\n                \n                void main() {\n                    vLife = life;\n                    vSpeed = speed;\n                    \n                    vec3 pos = position;\n                    pos.y += sin(time * speed + position.x) * 0.5;\n                    \n                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n                    gl_PointSize = particleSize * (1.0 - length(mvPosition.xyz) / 100.0) * life;\n                    gl_Position = projectionMatrix * mvPosition;\n                }\n            `,\n            fragmentShader: `\n                uniform float time;\n                uniform float dataIntensity;\n                uniform vec3 color;\n                \n                varying float vLife;\n                varying float vSpeed;\n                \n                void main() {\n                    vec2 center = gl_PointCoord - vec2(0.5);\n                    float dist = length(center);\n                    \n                    if (dist > 0.5) discard;\n                    \n                    float alpha = (1.0 - dist * 2.0) * vLife * dataIntensity;\n                    alpha *= sin(time * vSpeed) * 0.3 + 0.7;\n                    \n                    gl_FragColor = vec4(color, alpha);\n                }\n            `,\n            transparent: true,\n            blending: THREE.AdditiveBlending\n        });\n        \n        return material;\n    }\n    \n    // üåü Create Procedural Textures\n    createProceduralTextures() {\n        // Create canvas for procedural textures\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = 512;\n        this.canvas.height = 512;\n        this.ctx = this.canvas.getContext('2d');\n    }\n    \n    // üèóÔ∏è Concrete Texture Generator\n    createConcreteTexture() {\n        const canvas = this.canvas;\n        const ctx = this.ctx;\n        \n        // Base concrete color\n        ctx.fillStyle = '#666666';\n        ctx.fillRect(0, 0, 512, 512);\n        \n        // Add noise and variations\n        const imageData = ctx.getImageData(0, 0, 512, 512);\n        const data = imageData.data;\n        \n        for (let i = 0; i < data.length; i += 4) {\n            const noise = (Math.random() - 0.5) * 40;\n            data[i] += noise;     // R\n            data[i + 1] += noise; // G\n            data[i + 2] += noise; // B\n        }\n        \n        // Add wear patterns\n        ctx.putImageData(imageData, 0, 0);\n        \n        // Create texture\n        const texture = new THREE.CanvasTexture(canvas);\n        texture.wrapS = THREE.RepeatWrapping;\n        texture.wrapT = THREE.RepeatWrapping;\n        texture.repeat.set(10, 6);\n        \n        return texture;\n    }\n    \n    // üéØ Status Color Mapping\n    getStatusColor(status) {\n        const colors = {\n            'running': new THREE.Color(0x00ff88),\n            'idle': new THREE.Color(0xffaa00),\n            'maintenance': new THREE.Color(0xff4757),\n            'offline': new THREE.Color(0x888888),\n            'warning': new THREE.Color(0xffa502),\n            'error': new THREE.Color(0xff0000),\n            'optimal': new THREE.Color(0x88ff00)\n        };\n        return colors[status] || colors['offline'];\n    }\n    \n    // üåç Environment Maps\n    setupEnvironmentMaps() {\n        // Industrial environment reflection\n        try {\n            const envMap = this.createIndustrialEnvironmentMap();\n            this.environmentMap = envMap;\n        } catch (error) {\n            console.warn('‚ö†Ô∏è Environment map creation failed, using fallback');\n            this.environmentMap = null;\n        }\n    }\n    \n    getEnvironmentMap() {\n        return this.environmentMap;\n    }\n    \n    // ‚öôÔ∏è Advanced Vertex Shader\n    getAdvancedVertexShader() {\n        return `\n            varying vec3 vNormal;\n            varying vec3 vPosition;\n            varying vec2 vUv;\n            varying vec3 vViewPosition;\n            \n            uniform float time;\n            uniform float vibration;\n            \n            void main() {\n                vNormal = normalize(normalMatrix * normal);\n                vUv = uv;\n                \n                // Add subtle vibration for running machines\n                vec3 pos = position;\n                if (vibration > 0.0) {\n                    pos += normal * sin(time * 50.0) * vibration * 0.01;\n                }\n                \n                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n                vViewPosition = -mvPosition.xyz;\n                vPosition = pos;\n                \n                gl_Position = projectionMatrix * mvPosition;\n            }\n        `;\n    }\n    \n    // üé® Machine Fragment Shader\n    getMachineFragmentShader() {\n        return `\n            uniform float time;\n            uniform float machineStatus;\n            uniform float healthScore;\n            uniform vec3 baseColor;\n            uniform vec3 statusColor;\n            uniform float metalness;\n            uniform float roughness;\n            \n            varying vec3 vNormal;\n            varying vec3 vPosition;\n            varying vec2 vUv;\n            varying vec3 vViewPosition;\n            \n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n                \n                // Base material color\n                vec3 diffuse = mix(baseColor, statusColor, 0.3);\n                \n                // Health-based color modification\n                if (healthScore < 0.5) {\n                    diffuse = mix(diffuse, vec3(1.0, 0.0, 0.0), (0.5 - healthScore) * 2.0);\n                } else if (healthScore > 0.9) {\n                    diffuse = mix(diffuse, vec3(0.0, 1.0, 0.0), (healthScore - 0.9) * 10.0);\n                }\n                \n                // Status indicator glow\n                float statusGlow = 0.0;\n                if (machineStatus > 0.5) {\n                    statusGlow = sin(time * 3.0) * 0.1 + 0.1;\n                }\n                \n                // Simple lighting\n                vec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));\n                float ndotl = max(dot(normal, lightDir), 0.0);\n                \n                vec3 finalColor = diffuse * (ndotl * 0.8 + 0.2) + statusColor * statusGlow;\n                \n                gl_FragColor = vec4(finalColor, 1.0);\n            }\n        `;\n    }\n    \n    // üîÑ Update Material Uniforms\n    updateMaterialUniforms(deltaTime) {\n        this.shaderUniforms.time.value += deltaTime;\n        \n        // Update all cached materials with shader uniforms\n        this.materialCache.forEach(material => {\n            if (material.uniforms) {\n                Object.keys(this.shaderUniforms).forEach(key => {\n                    if (material.uniforms[key]) {\n                        material.uniforms[key].value = this.shaderUniforms[key].value;\n                    }\n                });\n            }\n        });\n    }\n    \n    // üìä Update Machine Status Material\n    updateMachineStatus(machineId, status, healthScore = 1.0, temperature = 20) {\n        const materialKey = `machine_${machineId}`;\n        const material = this.materialCache.get(materialKey);\n        \n        if (material && material.uniforms) {\n            material.uniforms.statusColor.value = this.getStatusColor(status);\n            material.uniforms.healthScore.value = healthScore;\n            material.uniforms.temperature.value = temperature;\n            \n            // Update vibration based on status\n            const vibrationLevels = {\n                'running': 0.5,\n                'idle': 0.1,\n                'maintenance': 0.0,\n                'warning': 0.8,\n                'error': 1.0,\n                'offline': 0.0\n            };\n            \n            material.uniforms.vibration.value = vibrationLevels[status] || 0.0;\n        }\n    }\n    \n    // üßπ Cleanup\n    dispose() {\n        this.materialCache.forEach(material => material.dispose());\n        this.materialCache.clear();\n        \n        if (this.environmentMap) {\n            this.environmentMap.dispose();\n        }\n        \n        console.log('üßπ Advanced 3D materials cleaned up');\n    }\n}\n\n// üöÄ Export for use in other modules\nif (typeof window !== 'undefined') {\n    window.Advanced3DMaterials = Advanced3DMaterials;\n}\n\nexport default Advanced3DMaterials;