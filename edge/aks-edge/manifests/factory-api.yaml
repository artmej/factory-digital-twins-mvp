---
apiVersion: v1
kind: ConfigMap
metadata:
  name: factory-api-config
data:
  POSTGRES_HOST: "postgresql-service"
  POSTGRES_PORT: "5432"
  POSTGRES_DB: "smart_factory"
  POSTGRES_USER: "factory_user"
  POSTGRES_PASSWORD: "SmartFactory2025!"
  INFLUX_URL: "http://influxdb-service:8086"
  INFLUX_DB: "smart_factory_metrics"
  REDIS_URL: "redis://redis-service:6379"
  ML_INFERENCE_URL: "http://ml-inference-service:8080"

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: factory-api
  labels:
    app: factory-api
    tier: api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: factory-api
  template:
    metadata:
      labels:
        app: factory-api
        tier: api
    spec:
      initContainers:
      - name: init-db
        image: postgres:15-alpine
        env:
        - name: PGPASSWORD
          value: "SmartFactory2025!"
        command:
        - /bin/bash
        - -c
        - |
          until pg_isready -h postgresql-service -p 5432 -U factory_user; do
            echo "Waiting for database..."
            sleep 2
          done
          
          # Create tables
          psql -h postgresql-service -U factory_user -d smart_factory << 'EOF'
          CREATE TABLE IF NOT EXISTS machines (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            type VARCHAR(50) NOT NULL,
            status VARCHAR(20) DEFAULT 'operational',
            location VARCHAR(100),
            installed_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            last_maintenance TIMESTAMP,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );
          
          CREATE TABLE IF NOT EXISTS sensors (
            id SERIAL PRIMARY KEY,
            machine_id INTEGER REFERENCES machines(id),
            sensor_type VARCHAR(50) NOT NULL,
            unit VARCHAR(20),
            min_value DECIMAL,
            max_value DECIMAL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );
          
          CREATE TABLE IF NOT EXISTS maintenance_logs (
            id SERIAL PRIMARY KEY,
            machine_id INTEGER REFERENCES machines(id),
            maintenance_type VARCHAR(50) NOT NULL,
            description TEXT,
            performed_by VARCHAR(100),
            performed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            cost DECIMAL,
            duration_hours DECIMAL
          );
          
          -- Insert sample data
          INSERT INTO machines (name, type, location) VALUES 
          ('CNC-001', 'CNC Machine', 'Production Line 1'),
          ('PRESS-001', 'Hydraulic Press', 'Production Line 2'),
          ('CONV-001', 'Conveyor Belt', 'Packaging Area')
          ON CONFLICT DO NOTHING;
          
          INSERT INTO sensors (machine_id, sensor_type, unit, min_value, max_value) VALUES 
          (1, 'temperature', 'celsius', 20, 100),
          (1, 'vibration', 'mm/s', 0, 10),
          (2, 'pressure', 'bar', 0, 200),
          (2, 'temperature', 'celsius', 20, 80),
          (3, 'speed', 'rpm', 0, 1800)
          ON CONFLICT DO NOTHING;
          EOF
      containers:
      - name: factory-api
        image: node:18-alpine
        ports:
        - containerPort: 3000
        envFrom:
        - configMapRef:
            name: factory-api-config
        command:
        - /bin/sh
        - -c
        - |
          npm init -y
          npm install express pg redis influxdb cors helmet morgan
          
          cat > app.js << 'EOF'
          const express = require('express');
          const { Pool } = require('pg');
          const redis = require('redis');
          const cors = require('cors');
          const helmet = require('helmet');
          const morgan = require('morgan');
          
          const app = express();
          
          // Middleware
          app.use(helmet());
          app.use(cors());
          app.use(morgan('combined'));
          app.use(express.json());
          
          // Database connections
          const pgPool = new Pool({
            host: process.env.POSTGRES_HOST,
            port: process.env.POSTGRES_PORT,
            database: process.env.POSTGRES_DB,
            user: process.env.POSTGRES_USER,
            password: process.env.POSTGRES_PASSWORD
          });
          
          const redisClient = redis.createClient({
            url: process.env.REDIS_URL
          });
          
          redisClient.connect().catch(console.error);
          
          // Health check
          app.get('/health', (req, res) => {
            res.json({ 
              status: 'healthy', 
              service: 'factory-api',
              timestamp: new Date().toISOString()
            });
          });
          
          // Machines endpoints
          app.get('/api/machines', async (req, res) => {
            try {
              const result = await pgPool.query('SELECT * FROM machines ORDER BY id');
              res.json(result.rows);
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });
          
          app.get('/api/machines/:id', async (req, res) => {
            try {
              const { id } = req.params;
              const result = await pgPool.query('SELECT * FROM machines WHERE id = $1', [id]);
              
              if (result.rows.length === 0) {
                return res.status(404).json({ error: 'Machine not found' });
              }
              
              res.json(result.rows[0]);
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });
          
          app.post('/api/machines', async (req, res) => {
            try {
              const { name, type, location } = req.body;
              const result = await pgPool.query(
                'INSERT INTO machines (name, type, location) VALUES ($1, $2, $3) RETURNING *',
                [name, type, location]
              );
              res.status(201).json(result.rows[0]);
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });
          
          // Sensors endpoints
          app.get('/api/machines/:id/sensors', async (req, res) => {
            try {
              const { id } = req.params;
              const result = await pgPool.query('SELECT * FROM sensors WHERE machine_id = $1', [id]);
              res.json(result.rows);
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });
          
          // Maintenance endpoints
          app.get('/api/machines/:id/maintenance', async (req, res) => {
            try {
              const { id } = req.params;
              const result = await pgPool.query(
                'SELECT * FROM maintenance_logs WHERE machine_id = $1 ORDER BY performed_at DESC',
                [id]
              );
              res.json(result.rows);
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });
          
          app.post('/api/machines/:id/maintenance', async (req, res) => {
            try {
              const { id } = req.params;
              const { maintenance_type, description, performed_by, cost, duration_hours } = req.body;
              
              const result = await pgPool.query(
                'INSERT INTO maintenance_logs (machine_id, maintenance_type, description, performed_by, cost, duration_hours) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *',
                [id, maintenance_type, description, performed_by, cost, duration_hours]
              );
              
              // Update machine last maintenance
              await pgPool.query(
                'UPDATE machines SET last_maintenance = CURRENT_TIMESTAMP WHERE id = $1',
                [id]
              );
              
              res.status(201).json(result.rows[0]);
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });
          
          // ML Integration endpoint
          app.post('/api/machines/:id/analyze', async (req, res) => {
            try {
              const { id } = req.params;
              const { sensor_values } = req.body;
              
              // Call ML inference service
              const response = await fetch(`${process.env.ML_INFERENCE_URL}/predict/anomaly`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  machine_id: id,
                  sensor_values
                })
              });
              
              if (!response.ok) {
                throw new Error('ML service error');
              }
              
              const analysis = await response.json();
              res.json(analysis);
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });
          
          // Start server
          const PORT = process.env.PORT || 3000;
          app.listen(PORT, '0.0.0.0', () => {
            console.log(`Factory API server running on port ${PORT}`);
          });
          EOF
          
          node app.js
        workingDir: /app
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: factory-api-service
  labels:
    app: factory-api
spec:
  type: NodePort
  ports:
  - port: 3000
    nodePort: 30003
    protocol: TCP
  selector:
    app: factory-api